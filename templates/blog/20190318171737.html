<h2>配列について理解する</h2>


　C言語の<b>配列</b>について理解しましょう。Perlの配列は、動的な配列です。つまり、配列の大きさを気にせずに、要素を追加することができます。一方C言語の配列は、固定された大きさを持ちます。

<h3>配列の宣言と初期化</h3>

　配列の宣言は次のように行います。

<pre>
型名 変数名[サイズ];
</pre>

　実際の配列の宣言です。

<pre>
/* 配列の宣言 */
int nums[3];
double nums[3];
char nums[3];
</pre>

　3つのサイズしか持たないので、3つの値しか代入することができません。サイズを増やすこともできません。

　<b>{}</b>を使って初期化を同時に行うこともできます。

<pre>
/* 配列の初期化 */
int nums[3] = {1, 2, 3};
double nums[3] = {1.5, 2.4, 6.5};
char nums[3] = {'a', 'b', 'c'};
</pre>

<h3>配列のループ</h3>

　配列をループしてみましょう。配列の個数は自分で管理する必要があります。Perlのlengthのように配列の長さを取り出すことはできません。

<pre>
int nums[3] = {1, 2, 3};

int i;
for (i = 0; i < 3; i++) {
  printf("%d\n", nums[i]);
}
</pre>

<h3>よくある質問</h3>

<h4>解説では、配列の要素数がべた書きされて「3」という数字が二回でてきていますが、回避できませんか。</h4>

　C言語では、変数を使って、配列のサイズを指定することができません。マクロを使って定数を定義することで回避できます。C言語は、いろいろやろうとすると読みづらくなっていきますけどね。

<pre>
<h3> define NUMS_COUNT 3</h3>

int nums[NUMS_COUNT] = {1, 2, 3};

int i;
for (i = 0; i < NUMS_COUNT; i++) {
  printf("%d\n", nums[i]);
}
</pre>

　けれども、通常は動的な配列を作成すると思います。以下で解説しています。

<h4>Perlのような動的な配列をC言語ではどのように作成すればよいですか</h4>

　C言語では、動的な配列を扱うテクニックは、別にあります。そのためには、「メモリを動的に確保する方法」と、「ポインタの知識」が必要になります。詳しいことは、動的配列の項目で解説したいと思いますが、サンプルを記述しておきます。

<pre>
/* intのポインタ型の宣言 */
int* nums;

/* int型を3個格納できるメモリを動的に確保 */
nums = (int*)malloc(sizeof(int) * 3);

/* 要素に代入 */
nums[0] = 1;
nums[1] = 2;
nums[2] = 3;

/* 確保したメモリの解放 */
free(nums);
</pre>

<h4>上記の方法で、動的な配列のメモリを一度に確保できることはわかりますが、push,pop,shift,unshiftなどの操作はどのように行いますか。</h4>

　Perlの配列は、動的配列で、push,pop,shift,unshift、サイズの拡張などが簡単に行えますが、C言語だけの機能ではこれを行うのは、大変めんどうです。自分で、双方向連結リストというデータ構造を自作することが必要です。

　もし、便利なデータのコンテナが必要なのであれば、C++を使うのが、現実的な解決策になると思います。C++のstd::vectorというクラスを利用すれば、Perlによく似た動的な配列が作成できます。

<pre>
<h3>include <vector></h3>

// intの動的配列
std::vector<int> nums(3);

// (1, 2, 3)
nums[0] = 1;
nums[1] = 2;
nums[2] = 3;

// (5, 1, 2, 3)
nums.insert(nums.begin(), 5);
</pre>

<h3>サンプルコード</h3>

　配列を使ったサンプルです。

<pre>
<h3>include <stdio.h></h3>

int main () {
  int nums[3] = {1, 2, 3};
  
  int i;
  for (i = 0; i < 3; i++) {
    printf("%d\n", nums[i]);
  }
}
</pre>

　実行しましょう。

<pre>
gcc -o test test.c && ./test
</pre>

　実行すると以下の結果を得ることができます。

<pre>
1
2
3
</pre>
